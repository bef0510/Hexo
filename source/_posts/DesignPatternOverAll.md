---
title: 設計模式
date: 2019-05-13 11:35:34
tags:
 - Creational
 - Structural
 - Behavior
 - C#
categories: 
 - Design Pattern
---

# 創建型模式 (Creational Pattern)
對類別的實例化過程進行了抽象，能夠將軟件模塊中對象的創建和對象的使用分離。為了使軟件的結構更加清晰，外界對於這些對像只需要知道它們共同的接口，而不清楚其具體的實現細節，使整個系統的設計更加符合單一職責原則

1. **工廠方法模式 `(Factory Method Pattern)`**
定義一個介面用於建立物件，但是讓子類別決定初始化哪個類。工廠方法把一個類的初始化下放到子類別

2. **抽象工廠模式 `(Abstract Factory Pattern)`**
為一個產品族提供了統一的建立介面。當需要這個產品族的某一系列的時候，可以從抽象工廠中選出相應的系列建立一個具體的工廠類

3. **建造者模式 `(Builder Pattern)`**
將一個複雜物件的構建與它的表示分離，使得同樣的構建過程可以建立不同的表示

4. **原型模式 `(Prototype Pattern)`**
用原型實體指定建立物件的種類，並且通過拷貝這些原型,建立新的物件

5. **單例模式 `(Singleton Pattern)`**
確保一個類只有一個實體，並提供對該實體的全域存取

# 結構型模式 (Structural Pattern)
描述如何將類或者對象結合在一起形成更大的結構，就像搭積木，可以通過簡單積木的組合形成複雜的，功能更為強大的結構

1. **適配器模式 `(Adapter Pattern)`**
將某個類的介面轉換成用戶端期望的另一個介面表示。配接器模式可以消除由於介面不符合所造成的類相容性問題

2. **橋接模式 `(Bridge Pattern)`**
將一個抽象與實現解耦，以便兩者可以獨立的變化

3. **組合模式 `(Composite Pattern)`**
把多個物件組成樹狀結構來表示局部與整體，這樣用戶可以一樣的對待單個物件和物件的組合

4. **裝飾模式 `(Decorator Pattern)`**
向某個物件動態地添加更多的功能。修飾模式是除類繼承外另一種擴充功能的方法

5. **外觀模式 `(Facade Pattern)`**
為子系統中的一組介面提供一個一致的介面， 外觀模式定義了一個高層介面，這個介面使得這一子系統更加容易使用

6. **享元模式 `(Flyweight Pattern)`**
通過共用以便有效的支援大量小顆粒物件

7. **代理模式 `(Proxy Pattern)`**
為其他物件提供一個代理以控制對這個物件的存取

# 行為型模式 (Behavioral Pattern)
用來識別對象之間的常用交流模式並加以實現。如此，可在進行這些交流活動時增強彈性

1. **責任鏈模式 `(Chain of Responsibility Pattern)`**
為解除請求的傳送者和接收者之間耦合，而使多個物件都有機會處理這個請求。將這些物件連成一條鏈，並沿著這條鏈傳遞該請求，直到有一個物件處理它

2. **命令模式 `(Command Pattern)`**
將一個請求封裝為一個物件，從而使你可用不同的請求對客戶進行參數化；對請求排隊或記錄請求紀錄檔，以及支援可取消的操作

3. **解釋器模式 `(Interpreter Pattern)`**
給定一個語言, 定義它的文法的一種表示，並定義一個直譯器, 該直譯器使用該表示來解釋語言中的句子

4. **迭代器模式 `(Iterator Pattern)`**
提供一種方法順序存取一個聚合物件中各個元素, 而又不需暴露該物件的內部表示

5. **中介者模式 `(Mediator Pattern)`**
包裝了一系列物件相互作用的方式，使得這些物件不必相互明顯作用，從而使它們可以鬆散偶合。當某些物件之間的作用發生改變時，不會立即影響其他的一些物件之間的作用，保證這些作用可以彼此獨立的變化

6. **備忘錄模式 `(Memento Pattern)`**
備忘錄物件是一個用來儲存另外一個物件內部狀態的快照的物件。備忘錄模式的用意是在不破壞封裝的條件下，將一個物件的狀態捉住，並外部化，儲存起來，從而可以在將來合適的時候把這個物件還原到儲存起來的狀態

7. **觀察者模式 `(Observer Pattern)`**
在物件間定義一個一對多的聯絡性，由此當一個物件改變了狀態，所有其他相關的物件會被通知並且自動重新整理

8. **狀態模式 `(State Pattern)`**
讓一個物件在其內部狀態改變的時候，其行為也隨之改變。狀態模式需要對每一個系統可能取得的狀態創立一個狀態類的子類別。當系統的狀態變化時，系統便改變所選的子類別

9. **策略模式 `(Strategy Pattern)`**
定義一個演算法的系列，將其各個分裝，並且使他們有互動性。策略模式使得演算法在用戶使用的時候能獨立的改變

10. **模板方法模式 `(Template Method Pattern)`**
模板方法模式準備一個抽象類，將部分邏輯以具體方法及具體構造子類別的形式實現，然後聲明一些抽象方法來迫使子類別實現剩餘的邏輯。不同的子類別可以以不同的方式實現這些抽象方法，從而對剩餘的邏輯有不同的實現。先構建一個頂級邏輯框架，而將邏輯的細節留給具體的子類別去實現

11. **訪問者模式 `(Visitor Pattern)`**
封裝一些施加於某種資料結構元素之上的操作。一旦這些操作需要修改，接受這個操作的資料結構可以保持不變。存取者模式適用於資料結構相對未定的系統，它把資料結構和作用於結構上的操作之間的耦合解脫開，使得操作集合可以相對自由的演化

# Reference
[維基百科-設計模式](https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)