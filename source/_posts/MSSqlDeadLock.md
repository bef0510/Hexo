---
title: MS SQL 鎖定 (Dead Lock)
date: 2019-07-11 14:57:42
tags:
 - Structrue
categories:
 - MS SQL
---

# 鎖定 (Dead Lock)
    SELECT * FROM sys.dm_tran_locks

* 共享鎖 **(S)**：
    查詢資料時會在該資源放置共享鎖，允許不同連接讀取相同資料；但此時若有人想要更新資料，必須等到釋放共享鎖後，才可放置獨佔鎖，共享鎖在取完資料後就會釋放，不會等到持續到交易結束。
* 獨佔鎖 **(X)**：
    新增、修改、刪除時，會對該資料放置獨佔鎖；獨佔鎖會一直保留到交易結束，且一個資源只會有一個獨佔鎖。
* 更新鎖 **(U)**：
    當資源由查詢轉換為更新時，鎖定機制會先由共享鎖 --> 更新鎖 --> 獨佔鎖；
    例如: **UPDATE…WHETE…**，先搜尋 (放置共享鎖) --> 找到資料後 (放置更新鎖) 共享鎖與更新鎖不互斥，先更新者由共享鎖轉為更新鎖後，因更新鎖彼此互斥，所以後更新者進入停止狀態，先更新者再將更新鎖轉為獨佔鎖，由於獨佔鎖與共享鎖互斥，所以更新時亦不可查詢資料，除非不下共享鎖 ( **With NOLOCK** )
* 意圖鎖 **(I)**：
    放置共享鎖前，必須對該筆紀錄的更大範圍設定意圖鎖，例如對該筆資料的 **Page** 或 **Table** 放置意圖鎖，以避免其他交易對該 **Page** 或 **Table** 放置獨佔鎖；因為意圖鎖彼此不互斥，當修改某筆記錄，會在該筆記錄放置獨佔鎖，而在該分頁放置意圖獨佔鎖，此時，其他交易要修改同分頁的其他記錄，則可對其記錄下獨佔鎖，對同分頁下意圖獨佔鎖。
* 大量更新 **(BU)**：
    當大量資料需複製到資料表時，指定 **TABLOCK** 或設 **sp_tableoption** 選項(將資料表設定為 **"table lock on bulk load"** ，則使用大量更新鎖。允許多個執行緒將資料同時大量載入同一資料表，同時禁止非大量載入資料的處理序存取資料，以提升大量匯入作業的效能
* 索引鍵範圍 **(Key-Range)**：
    使用Serializable的隔離層次，保護使用者查詢時所讀取的資料列範圍，以確保其他交易無法插入受索引鍵範圍保護的資料列。此種鎖定可封鎖任何嘗試插入、更新、刪除含有索引鍵範圍的資料列。另外，**UPDATE…WHERE…** 在搜尋符合記錄時，也有可能下索引鍵範圍鎖。
* 結構描述穩定性鎖定 **(Sch-S)**：
    查詢資料表結構時下的鎖定，只有在 **Sch-M** 不可執行。
* 結構描述修改鎖定 **(Sch-M)**：
    變更資料表結構( **DDL** 作業)時下的鎖定，**Sch-M** 鎖定時，**DDL** 作業和並行 **DML** 作業皆無法在資料表上執行
* 各種鎖定之間的互斥關係
![Architecture](1.png)

# 避免LOCK
* **NOLOCK**：
    忽略鎖，直接從數據庫讀取數據，可能讀取到未認可的資料，使得資料不正確。通常使用在 **Select**
* **ROWLOCK**：
    只對某一行資料上鎖，可避免對同個 **TABLE** 或 **PAGE** 造成 **LOCK**，但過多的行級鎖，在開鎖時會消耗更多的效能，適合用在有指定主鍵的 **Update**、**Delete** 行為上
* **UPDLOCK**：
    讀取表時使用更新鎖，而不使用共享鎖，並將鎖一直保留到處理序結束，通常使用在先 **Select** 後 **Update**，直接在 **Select** 時下更新鎖，不讓其他處理序有機會上獨佔鎖，直到原處理序結束，其他處理才能執行
• 一般使用前兩者皆可

# 隔離層次
* **Serializable**：
    強制所有的交易都必須按照順序，而且外部的查詢在 **Serialize** 的交易結束前，都不能讀取在交易中被鎖定住的資源
* **Read Uncommitted**：
    允許其他查詢在交易未完成時，就可以讀取交易範圍內的資源
* **Read Committed**：
    只允許其他查詢讀取已認可 **(Committed)** 的交易資料
* **Repeatable Read**：
    它具有 **Read Committed** 的特性，但又不允許其他交易修改交易內參考到的資源，以保證資料是可重覆讀取 **(Repeatable Read)** 的
* **Snapshot Isolation**：
    交易進行前會複製交易內相關的資源的資料到 **tempdb** 中，所有交易會在這個複本中進行，所以原本的資料讀取不會受到鎖定影響，而在多個交易同時進行時，**Snapshot** 會使用資料列版本 **(rowversion)** 的識別機制來判斷認可交易時的寫入順序，也因為它是在副本中進行，所以不會發生 **Dirty Read**, **Nonrepeatable Read** 與 **Phantom Read** 的狀態

# 開啟追蹤旗標
    USE master
    GO
    -- 啟用追蹤旗標 1204、1222。
    DBCC TRACEON (1204, 1222,-1)
    GO

# SQL SERVER  記錄檔 查詢死結
    EXEC master.dbo.xp_readerrorlog 0, 1, N'deadlock-list'
    EXEC master.dbo.xp_readerrorlog 0, 1, NULL,NULL,'2016-08-30 15:32:32.170','2016-08-30 15:32:33.170','ASC'
    參數說明：
    @p1 參數：0 表示目前的錯誤記錄檔，1 表示前一次的錯誤記錄檔之備份，2 表示前二次的錯誤記錄檔之備份，依此類推。
    @p2 參數：1 或是 NULL 表示 SQL Server 錯誤記錄檔；2 表示 SQL Server Agent 錯誤記錄檔
    @p3 參數：作為要查詢條件字串1。
    @p4 參數：作為要查詢條件字串2，與 @p3 參數為 AND 條件式。
    @p5 參數：指定錯誤記錄檔要讀取的起始日期。
    @p6 參數：指定錯誤記錄檔要讀取的終止日期。
    @p7 參數：可以設定查詢出來的資料之排序方式，依據「LogDate」資料行來排序，可以使用「ASC」或「DESC」參數值。

